{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"python-configuration","text":"<p>A library to load configuration parameters hierarchically from multiple sources and formats</p> <p> </p> <p>This library is intended as a helper mechanism to load configuration files hierarchically.</p>"},{"location":"#supported-formats","title":"Supported Formats","text":"<p>The <code>python-configuration</code> library supports the following configuration formats and sources:</p> <ul> <li>Python files</li> <li>Dictionaries</li> <li>Environment variables</li> <li>Filesystem paths</li> <li>JSON files</li> <li>INI files </li> <li>dotenv type files</li> <li>Optional support for:</li> <li>YAML files: requires <code>yaml</code></li> <li>TOML files: requires <code>tomli</code> for Python &lt; 3.11</li> <li>Azure Key Vault credentials: requires <code>azure-keyvault</code></li> <li>AWS Secrets Manager credentials: requires <code>boto3</code></li> <li>GCP Secret Manager credentials: requires <code>google-cloud-secret-manager</code></li> <li>Hashicorp Vault credentials: requires <code>hvac</code></li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install the library:</p> <pre><code>pip install python-configuration\n</code></pre> <p>To include the optional TOML and/or YAML loaders, install the optional dependencies <code>toml</code> and <code>yaml</code>. For example,</p> <pre><code>pip install python-configuration[toml,yaml]\n</code></pre> <p>Without the optional dependencies, the TOML (Python &lt; 3.11) and YAML loaders will not be available,  and attempting to use them will raise an exception.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p><code>python-configuration</code> converts the various config types into dictionaries with dotted-based keys. For example, given this JSON configuration</p> <pre><code>{\n    \"a\": {\n        \"b\": \"value\"\n    }\n}\n</code></pre> <p>We can use the <code>config_from_json</code> method to parse it:</p> <pre><code>from config import config_from_json\n\ncfg = config_from_json(\"my_config_file.json\", read_from_file=True)\n</code></pre> <p>(Similar methods exist for all the other supported configuration formats (eg. <code>config_from_toml</code>, etc.).)</p> <p>We are then able to refer to the parameters in the config above using any of:</p> <pre><code>cfg['a.b']\ncfg['a']['b']\ncfg['a'].b\ncfg.a.b\n</code></pre> <p>and extract specific data types such as dictionaries:</p> <pre><code>cfg['a'].as_dict == {'b': 'value'}\n</code></pre> <p>This is particularly useful in order to isolate group parameters. For example, with the JSON configuration</p> <pre><code>{\n  \"database.host\": \"something\",\n  \"database.port\": 12345,\n  \"database.driver\": \"name\",\n  \"app.debug\": true,\n  \"app.environment\": \"development\",\n  \"app.secrets\": \"super secret\",\n  \"logging\": {\n    \"service\": \"service\",\n    \"token\": \"token\",\n    \"tags\": \"tags\"\n  }\n}\n</code></pre> <p>one can retrieve the dictionaries as</p> <pre><code>cfg.database.as_dict()\ncfg.app.as_dict()\ncfg.logging.as_dict()\n</code></pre> <p>or simply as</p> <pre><code>dict(cfg.database)\ndict(cfg.app)\ndict(cfg.logging)\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>There are two general types of objects in this library. The first one is the <code>Configuration</code>, which represents a single config source.  The second is a <code>ConfigurationSet</code> that allows for multiple <code>Configuration</code> objects to be specified.</p>"},{"location":"#single-config","title":"Single Config","text":""},{"location":"#python-files","title":"Python Files","text":"<p>To load a configuration from a Python module, the <code>config_from_python</code> can be used. The first parameter must be a Python module and can be specified as an absolute path to the Python file or as an importable module.</p> <p>Optional parameters are the <code>prefix</code> and <code>separator</code>.  The following call</p> <pre><code>config_from_python('foo.bar', prefix='CONFIG', separator='__')\n</code></pre> <p>will read every variable in the <code>foo.bar</code> module that starts with <code>CONFIG__</code> and replace every occurrence of <code>__</code> with a <code>.</code>. For example,</p> <pre><code># foo.bar\nCONFIG__AA__BB_C = 1\nCONFIG__AA__BB__D = 2\nCONF__AA__BB__D = 3\n</code></pre> <p>would result in the configuration</p> <pre><code>{\n    'aa.bb_c': 1,\n    'aa.bb.d': 2,\n}\n</code></pre> <p>Note that the single underscore in <code>BB_C</code> is not replaced and the last line is not prefixed by <code>CONFIG</code>.</p>"},{"location":"#dictionaries","title":"Dictionaries","text":"<p>Dictionaries are loaded with <code>config_from_dict</code> and are converted internally to a flattened <code>dict</code>.</p> <pre><code>{\n    'a': {\n        'b': 'value'\n    }\n}\n</code></pre> <p>becomes</p> <pre><code>{\n    'a.b': 'value'\n}\n</code></pre>"},{"location":"#environment-variables","title":"Environment Variables","text":"<p>Environment variables starting with <code>prefix</code> can be read with <code>config_from_env</code>:</p> <pre><code>config_from_env(prefix, separator='_')\n</code></pre>"},{"location":"#filesystem-paths","title":"Filesystem Paths","text":"<p>Folders with files named as <code>xxx.yyy.zzz</code> can be loaded with the <code>config_from_path</code> function.  This format is useful to load mounted Kubernetes ConfigMaps or Secrets.</p>"},{"location":"#json-ini-env-yaml-toml","title":"JSON, INI, .env, YAML, TOML","text":"<p>JSON, INI, YAML, TOML files are loaded respectively with <code>config_from_json</code>, <code>config_from_ini</code>, <code>config_from_dotenv</code>, <code>config_from_yaml</code>, and <code>config_from_toml</code>. The parameter <code>read_from_file</code> controls whether a string should be interpreted as a filename.</p>"},{"location":"#caveats","title":"Caveats","text":"<p>In order for <code>Configuration</code> objects to act as <code>dict</code> and allow the syntax <code>dict(cfg)</code>, the <code>keys()</code> method is implemented as the typical <code>dict</code> keys. If <code>keys</code> is an element in the configuration <code>cfg</code> then the <code>dict(cfg)</code> call will fail. In that case, it's necessary to use the <code>cfg.as_dict()</code> method to retrieve the <code>dict</code> representation for the <code>Configuration</code> object.</p> <p>The same applies to the methods <code>values()</code> and <code>items()</code>.</p>"},{"location":"#configuration-sets","title":"Configuration Sets","text":"<p>Configuration sets are used to hierarchically load configurations and merge settings. Sets can be loaded by constructing a <code>ConfigurationSet</code> object directly or using the simplified <code>config</code> function.</p> <p>To construct a <code>ConfigurationSet</code>, pass in as many of the simple <code>Configuration</code> objects as needed:</p> <pre><code>cfg = ConfigurationSet(\n    config_from_env(prefix=PREFIX),\n    config_from_json(path, read_from_file=True),\n    config_from_dict(DICT),\n)\n</code></pre> <p>The example above will read first from Environment variables prefixed with <code>PREFIX</code>, and fallback first to the JSON file at <code>path</code>, and finally use the dictionary <code>DICT</code>.</p> <p>The <code>config</code> function simplifies loading sets by assuming some defaults. The example above can also be obtained by</p> <pre><code>cfg = config(\n    ('env', PREFIX),\n    ('json', path, True),\n    ('dict', DICT),\n)\n</code></pre> <p>or, even simpler if <code>path</code> points to a file with a <code>.json</code> suffix:</p> <pre><code>cfg = config('env', path, DICT, prefix=PREFIX)\n</code></pre> <p>The <code>config</code> function automatically detects the following:</p> <ul> <li>extension <code>.py</code> for python modules</li> <li>dot-separated python identifiers as a python module (e.g. <code>foo.bar</code>)</li> <li>extension <code>.json</code> for JSON files</li> <li>extension <code>.yaml</code> for YAML files</li> <li>extension <code>.toml</code> for TOML files</li> <li>extension <code>.ini</code> for INI files</li> <li>extension <code>.env</code> for dotenv type files</li> <li>filesystem folders as Filesystem Paths</li> <li>the strings <code>env</code> or <code>environment</code> for Environment Variables</li> </ul>"},{"location":"#merging-values","title":"Merging Values","text":"<p><code>ConfigurationSet</code> instances are constructed by inspecting each configuration source, taking into account nested dictionaries, and merging at the most granular level. For example, the instance obtained from <code>cfg = config(d1, d2)</code> for the dictionaries below</p> <pre><code>d1 = {'sub': {'a': 1, 'b': 4}}\nd2 = {'sub': {'b': 2, 'c': 3}}\n</code></pre> <p>is such that <code>cfg['sub']</code> equals</p> <pre><code>{'a': 1, 'b': 4, 'c': 3}\n</code></pre> <p>Note that the nested dictionaries of <code>'sub'</code> in each of <code>d1</code> and <code>d2</code> do not overwrite each other, but are merged into a single dictionary with keys from both <code>d1</code> and <code>d2</code>, giving priority to the values of <code>d1</code> over those from <code>d2</code>.</p>"},{"location":"#caveats_1","title":"Caveats","text":"<p>As long as the data types are consistent across all the configurations that are part of a <code>ConfigurationSet</code>, the behavior should be straightforward.  When different configuration objects are specified with competing data types, the first configuration to define the elements sets its datatype. For example, if in the example above <code>element</code> is interpreted as a <code>dict</code> from environment variables, but the JSON file specifies it as anything else besides a mapping, then the JSON value will be dropped automatically.</p>"},{"location":"#other-features","title":"Other Features","text":""},{"location":"#string-interpolation","title":"String Interpolation","text":"<p>When setting the <code>interpolate</code> parameter in any <code>Configuration</code> instance, the library will perform a string interpolation step using the str.format syntax.  In particular, this allows to format configuration values automatically:</p> <pre><code>cfg = config_from_dict({\n    \"percentage\": \"{val:.3%}\",\n    \"with_sign\": \"{val:+f}\",\n    \"val\": 1.23456,\n    }, interpolate=True)\n\nassert cfg.val == 1.23456\nassert cfg.with_sign == \"+1.234560\"\nassert cfg.percentage == \"123.456%\"\n</code></pre>"},{"location":"#validation","title":"Validation","text":"<p>Validation relies on the jsonchema library, which is automatically installed using the extra <code>validation</code>. To use it, call the <code>validate</code> method on any <code>Configuration</code> instance in a manner similar to what is described on the <code>jsonschema</code> library:</p> <pre><code>schema = {\n    \"type\" : \"object\",\n    \"properties\" : {\n        \"price\" : {\"type\" : \"number\"},\n        \"name\" : {\"type\" : \"string\"},\n    },\n}\n\ncfg = config_from_dict({\"name\" : \"Eggs\", \"price\" : 34.99})\nassert cfg.validate(schema)\n\ncfg = config_from_dict({\"name\" : \"Eggs\", \"price\" : \"Invalid\"})\nassert not cfg.validate(schema)\n\n# pass the `raise_on_error` parameter to get the traceback of validation failures\ncfg.validate(schema, raise_on_error=True)\n# ValidationError: 'Invalid' is not of type 'number'\n</code></pre> <p>To use the format feature of the <code>jsonschema</code> library, the extra dependencies must be installed separately as explained in the documentation of <code>jsonschema</code>.   </p> <pre><code>from jsonschema import Draft202012Validator\n\nschema = {\n    \"type\" : \"object\",\n    \"properties\" : {\n        \"ip\" : {\"format\" : \"ipv4\"},\n    },\n}\n\ncfg = config_from_dict({\"ip\": \"10.0.0.1\"})\nassert cfg.validate(schema, format_checker=Draft202012Validator.FORMAT_CHECKER)\n\ncfg = config_from_dict({\"ip\": \"10\"})\nassert not cfg.validate(schema, format_checker=Draft202012Validator.FORMAT_CHECKER)\n\n# with the `raise_on_error` parameter:\nc.validate(schema, raise_on_error=True, format_checker=Draft202012Validator.FORMAT_CHECKER)\n# ValidationError: '10' is not a 'ipv4'\n</code></pre>"},{"location":"#extras","title":"Extras","text":"<p>The <code>config.contrib</code> package contains extra implementations of the <code>Configuration</code> class used for special cases. Currently the following are implemented:</p> <ul> <li><code>AzureKeyVaultConfiguration</code> in <code>config.contrib.azure</code>, which takes Azure Key Vault   credentials into a <code>Configuration</code>-compatible instance. To install the needed dependencies   execute</li> </ul> <p><code>shell   pip install python-configuration[azure]</code></p> <ul> <li><code>AWSSecretsManagerConfiguration</code> in <code>config.contrib.aws</code>, which takes AWS Secrets Manager   credentials into a <code>Configuration</code>-compatible instance. To install the needed dependencies   execute</li> </ul> <p><code>shell   pip install python-configuration[aws]</code></p> <ul> <li><code>GCPSecretManagerConfiguration</code> in <code>config.contrib.gcp</code>, which takes GCP Secret Manager   credentials into a <code>Configuration</code>-compatible instance. To install the needed dependencies   execute</li> </ul> <p><code>shell   pip install python-configuration[gcp]</code></p> <ul> <li><code>HashicorpVaultConfiguration</code> in <code>config.contrib.vault</code>, which takes Hashicorp Vault   credentials into a <code>Configuration</code>-compatible instance. To install the needed dependencies   execute</li> </ul> <p><code>shell   pip install python-configuration[vault]</code></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Load multiple configuration types</li> <li>Hierarchical configuration</li> <li>Ability to override with environment variables</li> <li>Merge parameters from different configuration types</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to contribute, please fork the repository and use a feature branch. Pull requests are welcome.</p> <p>See <code>CONTRIBUTING.md</code> for the details.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Repository: https://github.com/tr11/python-configuration</li> <li>Issue tracker: https://github.com/tr11/python-configuration/issues</li> <li>Documentation: https://python-configuration.readthedocs.io</li> </ul>"},{"location":"#licensing","title":"Licensing","text":"<p>The code in this project is licensed under MIT license.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to python-configuration","text":"<p>First off, thanks for taking the time to contribute!</p>"},{"location":"CONTRIBUTING/#setting-up-a-dev-environment","title":"Setting up a dev environment","text":"<ol> <li>Fork the <code>tr11/python-configuration</code> GitHub repo.</li> <li> <p>Clone the fork:</p> <p><code>shell git clone https://github.com/&lt;your_username&gt;/python-configuration.git cd python-configuration</code></p> </li> <li> <p>Use <code>hatch</code> to generate a version file and install the dependencies</p> </li> </ol> <pre><code>hatch build --hooks-only  # generate a version file from the git commit\n# or\nhatch build\n</code></pre>"},{"location":"CONTRIBUTING/#running-the-tests","title":"Running the tests","text":"<p>To run the tests (which include linting and type checks), run:</p> <pre><code>hatch run test:test \n</code></pre> <p>Before opening a PR, make sure to run </p> <pre><code>hatch run testing:test \n</code></pre> <p>which executes the previous test command on all Python versions supported by the library.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0121-2024-07-23","title":"[0.12.1] - 2024-07-23","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>JsonSchema validation now has an extra parameter for nested schemas.</li> </ul>"},{"location":"changelog/#0120-2024-07-23","title":"[0.12.0] - 2024-07-23","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Granular <code>strip_prefix</code> parameters across different config types</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Unit tests for .toml files</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Enviroment files are now loaded from filenames with a suffix of <code>.env</code> or starting with <code>.env</code></li> </ul>"},{"location":"changelog/#0110-2024-04-23","title":"0.11.0 - 2024-04-23","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Allow passing a <code>pathlib.Path</code> parameter to methods that read configuration files</li> <li>Support comments in .env files</li> </ul>"},{"location":"changelog/#0100-2024-02-19","title":"0.10.0 - 2024-02-19","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Use the standard lib for <code>toml</code> in Python &gt;= 3.11</li> <li>Switched to <code>hatch</code> instead of <code>poetry</code></li> </ul>"},{"location":"changelog/#091-2023-08-06","title":"0.9.1 - 2023-08-06","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Allow to pass a <code>ignore_missing_paths</code> parameter to each config method</li> <li>Support for Hashicorp Vault credentials (in <code>config.contrib</code>)</li> <li>Added a <code>validate</code> method to validate <code>Configuration</code> instances against a json schema.</li> </ul>"},{"location":"changelog/#090-2023-08-04","title":"0.9.0 - 2023-08-04","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added the <code>section_prefix</code> parameter that filters sections by prefix in INI/toml files</li> <li>Allow the <code>ignore_missing_paths</code> parameter to be specified individually on Configuration Sets</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Errors when passing objects implementing <code>Mapping</code> instead of <code>dict</code></li> <li>Comparison to objects that are not a <code>Mapping</code> </li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Replaced TravisCI with GitHub Actions</li> </ul>"},{"location":"changelog/#083-2021-10-11","title":"0.8.3 - 2021-10-11","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Configurations from ini file won't be converted to lower case if <code>lowercase_keys = False</code></li> </ul>"},{"location":"changelog/#082-2021-01-30","title":"0.8.2 - 2021-01-30","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>The behavior of merging sets was incorrect since version 0.8.0</li> </ul>"},{"location":"changelog/#080-2020-08-01","title":"0.8.0 - 2020-08-01","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>The behavior of the dict-like methods <code>keys</code>, <code>items</code>, and <code>values</code> now give only the first level configuration keys instead of the old behavior of returning all the nested keys. To achieve the same behavior as before, use the <code>dotter_iter</code> context manager:</li> </ul> <pre><code>cfg.keys()  # returns only the top level keys\n\nwith cfg.dotted_iter():\n    cfg.keys()  # returns all the keys at all depths using '.' as a separator\n</code></pre>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Configuration objects are now immutable</li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Attribute dictionaries</li> <li>Support for .env-type files</li> <li>Option for deep interpolation. To activate that mode, use one of the enum values in <code>InterpolateEnumType</code> as the <code>interpolate_type</code> parameter. This allows for hierachical templates, in which configuration objects use the values from lower ones to interpolate instead of simply overriding.</li> </ul>"},{"location":"changelog/#071-2020-07-05","title":"0.7.1 - 2020-07-05","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Installation with <code>poetry</code> because of changes to pytest-black</li> </ul>"},{"location":"changelog/#070-2020-05-06","title":"0.7.0 - 2020-05-06","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>New string interpolation feature</li> </ul>"},{"location":"changelog/#061-2020-04-24","title":"0.6.1 - 2020-04-24","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Added a <code>separator</code> argument to <code>config</code> function</li> </ul>"},{"location":"changelog/#060-2020-01-22","title":"0.6.0 - 2020-01-22","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Added missing <code>dict</code> methods so a <code>Configuration</code> instance acts like a dictionary for most use cases</li> <li>Added a <code>reload</code> method to refresh a <code>Configuration</code> instance (can be used to reload a configuration from a file that may have changed).</li> <li>Added a <code>configs</code> method to expose the underlying instances of a <code>ConfigurationSet</code></li> </ul>"},{"location":"changelog/#050-2020-01-08","title":"0.5.0 - 2020-01-08","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Support for Azure Key Vault credentials (in <code>config.contrib</code>)</li> <li>Support for AWS Secrets Manager credentials (in <code>config.contrib</code>)</li> <li>Tox support</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Changed the <code>__repr__</code> and <code>__str__</code> methods so possibly sensitive values are not printed by default.</li> </ul>"},{"location":"changelog/#040-2019-10-11","title":"0.4.0 - 2019-10-11","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Allow path-based failures using the <code>config</code> function.</li> <li>Added a levels option to the dict-like objects.</li> </ul>"},{"location":"changelog/#031-2019-08-20","title":"0.3.1 - 2019-08-20","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Project now builds fine on ReadTheDocs</li> <li>TravisCI support</li> <li>Codecov</li> </ul>"},{"location":"changelog/#030-2019-08-16","title":"0.3.0 - 2019-08-16","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Changed the old behavior in which every key was converted to lower case.</li> </ul>"},{"location":"changelog/#020-2019-07-16","title":"0.2.0 - 2019-07-16","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added Sphinx documentation</li> <li>Added a <code>remove_levels</code> parameter to the config function</li> </ul>"},{"location":"changelog/#010-2019-01-16","title":"0.1.0 - 2019-01-16","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Initial version</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>python-configuration module.</p> <p>Configuration class.</p> <p>ConfigurationSet class.</p>"},{"location":"reference/#config.DotEnvConfiguration","title":"<code>DotEnvConfiguration</code>","text":"<p>               Bases: <code>FileConfiguration</code></p> <p>Configuration from a .env type file input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class DotEnvConfiguration(FileConfiguration):\n    \"\"\"Configuration from a .env type file input.\"\"\"\n\n    def __init__(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n        prefix: str = \"\",\n        separator: str = \"__\",\n        *,\n        strip_prefix: bool = True,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\"\"\"\n        self._prefix = prefix\n        self._strip_prefix = strip_prefix\n        self._separator = separator\n\n        super().__init__(\n            data=data,\n            read_from_file=read_from_file,\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n            ignore_missing_paths=ignore_missing_paths,\n        )\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:\n        \"\"\"Reload the .env data.\"\"\"\n        if read_from_file:\n            if isinstance(data, (str, Path)):\n                with open(data, \"rt\") as f:\n                    data = f.read()\n            else:\n                data = data.read()\n        data = cast(str, data)\n        result: Dict[str, Any] = dict(\n            parse_env_line(x) for x in data.splitlines() if x and not x.startswith(\"#\")\n        )\n\n        n = len(self._prefix) if self._strip_prefix else 0\n        result = {\n            k[n:].replace(self._separator, \".\").strip(\".\"): v\n            for k, v in result.items()\n            if k.startswith(self._prefix)\n        }\n\n        self._config = self._flatten_dict(result)\n</code></pre>"},{"location":"reference/#config.DotEnvConfiguration.__init__","title":"<code>__init__(data, read_from_file=False, prefix='', separator='__', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    prefix: str = \"\",\n    separator: str = \"__\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\"\"\"\n    self._prefix = prefix\n    self._strip_prefix = strip_prefix\n    self._separator = separator\n\n    super().__init__(\n        data=data,\n        read_from_file=read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.EnvConfiguration","title":"<code>EnvConfiguration</code>","text":"<p>               Bases: <code>Configuration</code></p> <p>Configuration from Environment variables.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class EnvConfiguration(Configuration):\n    \"\"\"Configuration from Environment variables.\"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        separator: str = \"__\",\n        *,\n        strip_prefix: bool = True,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ):\n        \"\"\"Class Constructor.\n\n        prefix: prefix to filter environment variables with\n        separator: separator to replace by dots\n        strip_prefix: whether to include the prefix\n        lowercase_keys: whether to convert every key to lower case.\n        \"\"\"\n        self._prefix = prefix\n        self._strip_prefix = strip_prefix\n        self._separator = separator\n        super().__init__(\n            {},\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n        )\n        self.reload()\n\n    def reload(self) -&gt; None:\n        \"\"\"Reload the environment values.\"\"\"\n        result = {}\n        for key, value in os.environ.items():\n            if not key.startswith(self._prefix + self._separator):\n                continue\n            if self._strip_prefix:\n                result[\n                    key[len(self._prefix) :].replace(self._separator, \".\").strip(\".\")\n                ] = value\n            else:\n                result[key.replace(self._separator, \".\").strip(\".\")] = value\n        super().__init__(\n            result,\n            lowercase_keys=self._lowercase,\n            interpolate=self._interpolate,\n            interpolate_type=self._interpolate_type,\n        )\n</code></pre>"},{"location":"reference/#config.EnvConfiguration.__init__","title":"<code>__init__(prefix='', separator='__', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Class Constructor.</p> <p>prefix: prefix to filter environment variables with separator: separator to replace by dots strip_prefix: whether to include the prefix lowercase_keys: whether to convert every key to lower case.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"\",\n    separator: str = \"__\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n):\n    \"\"\"Class Constructor.\n\n    prefix: prefix to filter environment variables with\n    separator: separator to replace by dots\n    strip_prefix: whether to include the prefix\n    lowercase_keys: whether to convert every key to lower case.\n    \"\"\"\n    self._prefix = prefix\n    self._strip_prefix = strip_prefix\n    self._separator = separator\n    super().__init__(\n        {},\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n    self.reload()\n</code></pre>"},{"location":"reference/#config.EnvConfiguration.reload","title":"<code>reload()</code>","text":"<p>Reload the environment values.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the environment values.\"\"\"\n    result = {}\n    for key, value in os.environ.items():\n        if not key.startswith(self._prefix + self._separator):\n            continue\n        if self._strip_prefix:\n            result[\n                key[len(self._prefix) :].replace(self._separator, \".\").strip(\".\")\n            ] = value\n        else:\n            result[key.replace(self._separator, \".\").strip(\".\")] = value\n    super().__init__(\n        result,\n        lowercase_keys=self._lowercase,\n        interpolate=self._interpolate,\n        interpolate_type=self._interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.FileConfiguration","title":"<code>FileConfiguration</code>","text":"<p>               Bases: <code>Configuration</code></p> <p>Configuration from a file input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class FileConfiguration(Configuration):\n    \"\"\"Configuration from a file input.\"\"\"\n\n    def __init__(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n        *,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\n\n        data: path to a config file, or its contents\n        read_from_file: whether to read from a file path or to interpret\n            the `data` as the contents of the file.\n        lowercase_keys: whether to convert every key to lower case.\n        \"\"\"\n        super().__init__(\n            {},\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n        )\n        self._filename = (\n            data if read_from_file and isinstance(data, (str, Path)) else None\n        )\n        self._ignore_missing_paths = ignore_missing_paths\n        self._reload_with_check(data, read_from_file)\n\n    def _reload_with_check(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:  # pragma: no cover\n        try:\n            self._reload(data, read_from_file)\n        except FileNotFoundError:\n            if not self._ignore_missing_paths:\n                raise\n            self._config = self._flatten_dict({})\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:  # pragma: no cover\n        raise NotImplementedError()\n\n    def reload(self) -&gt; None:\n        \"\"\"Reload the configuration.\"\"\"\n        if self._filename:  # pragma: no branch\n            self._reload_with_check(self._filename, True)\n</code></pre>"},{"location":"reference/#config.FileConfiguration.__init__","title":"<code>__init__(data, read_from_file=False, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> <p>data: path to a config file, or its contents read_from_file: whether to read from a file path or to interpret     the <code>data</code> as the contents of the file. lowercase_keys: whether to convert every key to lower case.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\n\n    data: path to a config file, or its contents\n    read_from_file: whether to read from a file path or to interpret\n        the `data` as the contents of the file.\n    lowercase_keys: whether to convert every key to lower case.\n    \"\"\"\n    super().__init__(\n        {},\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n    self._filename = (\n        data if read_from_file and isinstance(data, (str, Path)) else None\n    )\n    self._ignore_missing_paths = ignore_missing_paths\n    self._reload_with_check(data, read_from_file)\n</code></pre>"},{"location":"reference/#config.FileConfiguration.reload","title":"<code>reload()</code>","text":"<p>Reload the configuration.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the configuration.\"\"\"\n    if self._filename:  # pragma: no branch\n        self._reload_with_check(self._filename, True)\n</code></pre>"},{"location":"reference/#config.INIConfiguration","title":"<code>INIConfiguration</code>","text":"<p>               Bases: <code>FileConfiguration</code></p> <p>Configuration from an INI file input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class INIConfiguration(FileConfiguration):\n    \"\"\"Configuration from an INI file input.\"\"\"\n\n    def __init__(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n        *,\n        section_prefix: str = \"\",\n        strip_prefix: bool = True,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\"\"\"\n        self._section_prefix = section_prefix\n        self._strip_prefix = strip_prefix\n        super().__init__(\n            data=data,\n            read_from_file=read_from_file,\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n            ignore_missing_paths=ignore_missing_paths,\n        )\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:\n        \"\"\"Reload the INI data.\"\"\"\n        import configparser\n\n        lowercase = self._lowercase\n\n        class ConfigParser(configparser.RawConfigParser):\n            def optionxform(self, optionstr: str) -&gt; str:\n                return super().optionxform(optionstr) if lowercase else optionstr\n\n        if read_from_file:\n            if isinstance(data, (str, Path)):\n                with open(data, \"rt\") as f:\n                    data = f.read()\n            else:\n                data = data.read()\n        data = cast(str, data)\n        cfg = ConfigParser()\n        cfg.read_string(data)\n        n = len(self._section_prefix) if self._strip_prefix else 0\n        result = {\n            section[n:] + \".\" + k: v\n            for section, values in cfg.items()\n            for k, v in values.items()\n            if section.startswith(self._section_prefix)\n        }\n        self._config = self._flatten_dict(result)\n</code></pre>"},{"location":"reference/#config.INIConfiguration.__init__","title":"<code>__init__(data, read_from_file=False, *, section_prefix='', strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    section_prefix: str = \"\",\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\"\"\"\n    self._section_prefix = section_prefix\n    self._strip_prefix = strip_prefix\n    super().__init__(\n        data=data,\n        read_from_file=read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.JSONConfiguration","title":"<code>JSONConfiguration</code>","text":"<p>               Bases: <code>FileConfiguration</code></p> <p>Configuration from a JSON input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class JSONConfiguration(FileConfiguration):\n    \"\"\"Configuration from a JSON input.\"\"\"\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:\n        \"\"\"Reload the JSON data.\"\"\"\n        if read_from_file:\n            if isinstance(data, (str, Path)):\n                with open(data, \"rt\") as f:\n                    result = json.load(f)\n            else:\n                result = json.load(data)\n        else:\n            result = json.loads(cast(str, data))\n        self._config = self._flatten_dict(result)\n</code></pre>"},{"location":"reference/#config.PathConfiguration","title":"<code>PathConfiguration</code>","text":"<p>               Bases: <code>Configuration</code></p> <p>Configuration from a filesytem path.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class PathConfiguration(Configuration):\n    \"\"\"Configuration from a filesytem path.\"\"\"\n\n    def __init__(\n        self,\n        path: str,\n        remove_level: int = 1,\n        *,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\n\n        path: path to read from\n        remove_level: how many levels to remove from the resulting config\n        lowercase_keys: whether to convert every key to lower case.\n        \"\"\"\n        self._path = path\n        self._remove_level = remove_level\n        super().__init__(\n            {},\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n        )\n        self._ignore_missing_paths = ignore_missing_paths\n        self.reload()\n\n    def reload(self) -&gt; None:\n        \"\"\"Reload the path.\"\"\"\n        try:\n            path = os.path.normpath(self._path)\n            if not os.path.exists(path) or not os.path.isdir(path):\n                raise FileNotFoundError()\n\n            dotted_path_levels = len(path.split(\"/\"))\n            files_keys = (\n                (\n                    os.path.join(x[0], y),\n                    \".\".join(\n                        (x[0].split(\"/\") + [y])[\n                            (dotted_path_levels + self._remove_level) :\n                        ],\n                    ),\n                )\n                for x in os.walk(path)\n                for y in x[2]\n                if not x[0].split(\"/\")[-1].startswith(\"..\")\n            )\n\n            result = {}\n            for filename, key in files_keys:\n                with open(filename) as f:\n                    result[key] = f.read()\n        except FileNotFoundError:\n            if self._ignore_missing_paths:\n                result = {}\n            else:\n                raise\n        super().__init__(\n            result,\n            lowercase_keys=self._lowercase,\n            interpolate=self._interpolate,\n            interpolate_type=self._interpolate_type,\n        )\n</code></pre>"},{"location":"reference/#config.PathConfiguration.__init__","title":"<code>__init__(path, remove_level=1, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> <p>path: path to read from remove_level: how many levels to remove from the resulting config lowercase_keys: whether to convert every key to lower case.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    path: str,\n    remove_level: int = 1,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\n\n    path: path to read from\n    remove_level: how many levels to remove from the resulting config\n    lowercase_keys: whether to convert every key to lower case.\n    \"\"\"\n    self._path = path\n    self._remove_level = remove_level\n    super().__init__(\n        {},\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n    self._ignore_missing_paths = ignore_missing_paths\n    self.reload()\n</code></pre>"},{"location":"reference/#config.PathConfiguration.reload","title":"<code>reload()</code>","text":"<p>Reload the path.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the path.\"\"\"\n    try:\n        path = os.path.normpath(self._path)\n        if not os.path.exists(path) or not os.path.isdir(path):\n            raise FileNotFoundError()\n\n        dotted_path_levels = len(path.split(\"/\"))\n        files_keys = (\n            (\n                os.path.join(x[0], y),\n                \".\".join(\n                    (x[0].split(\"/\") + [y])[\n                        (dotted_path_levels + self._remove_level) :\n                    ],\n                ),\n            )\n            for x in os.walk(path)\n            for y in x[2]\n            if not x[0].split(\"/\")[-1].startswith(\"..\")\n        )\n\n        result = {}\n        for filename, key in files_keys:\n            with open(filename) as f:\n                result[key] = f.read()\n    except FileNotFoundError:\n        if self._ignore_missing_paths:\n            result = {}\n        else:\n            raise\n    super().__init__(\n        result,\n        lowercase_keys=self._lowercase,\n        interpolate=self._interpolate,\n        interpolate_type=self._interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.PythonConfiguration","title":"<code>PythonConfiguration</code>","text":"<p>               Bases: <code>Configuration</code></p> <p>Configuration from a python module.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class PythonConfiguration(Configuration):\n    \"\"\"Configuration from a python module.\"\"\"\n\n    def __init__(\n        self,\n        module: Union[str, Path, ModuleType],\n        prefix: str = \"\",\n        separator: str = \"_\",\n        *,\n        strip_prefix: bool = True,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\n\n        module: a module or path string\n        prefix: prefix to use to filter object names\n        separator: separator to replace by dots\n        lowercase_keys: whether to convert every key to lower case.\n        \"\"\"\n        try:\n            if isinstance(module, (str, Path)):\n                module = str(module)\n                if module.endswith(\".py\"):\n                    import importlib.util\n                    from importlib import machinery\n\n                    spec = cast(\n                        machinery.ModuleSpec,\n                        importlib.util.spec_from_file_location(module, module),\n                    )\n                    module = importlib.util.module_from_spec(spec)\n                    spec.loader = cast(InspectLoader, spec.loader)\n                    spec.loader.exec_module(module)\n                else:\n                    import importlib\n\n                    module = importlib.import_module(module)\n            self._module: Optional[ModuleType] = module\n            self._prefix = prefix\n            self._strip_prefix = strip_prefix\n            self._separator = separator\n        except (FileNotFoundError, ModuleNotFoundError):\n            if not ignore_missing_paths:\n                raise\n            self._module = None\n\n        super().__init__(\n            {},\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n        )\n        self.reload()\n\n    def reload(self) -&gt; None:\n        \"\"\"Reload the path.\"\"\"\n        if self._module is not None:\n            variables = [\n                x\n                for x in dir(self._module)\n                if not x.startswith(\"__\") and x.startswith(self._prefix)\n            ]\n            n = len(self._prefix) if self._strip_prefix else 0\n            result = {\n                k[n:].replace(self._separator, \".\").strip(\".\"): getattr(self._module, k)\n                for k in variables\n            }\n        else:\n            result = {}\n        super().__init__(\n            result,\n            lowercase_keys=self._lowercase,\n            interpolate=self._interpolate,\n            interpolate_type=self._interpolate_type,\n        )\n</code></pre>"},{"location":"reference/#config.PythonConfiguration.__init__","title":"<code>__init__(module, prefix='', separator='_', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> <p>module: a module or path string prefix: prefix to use to filter object names separator: separator to replace by dots lowercase_keys: whether to convert every key to lower case.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    module: Union[str, Path, ModuleType],\n    prefix: str = \"\",\n    separator: str = \"_\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\n\n    module: a module or path string\n    prefix: prefix to use to filter object names\n    separator: separator to replace by dots\n    lowercase_keys: whether to convert every key to lower case.\n    \"\"\"\n    try:\n        if isinstance(module, (str, Path)):\n            module = str(module)\n            if module.endswith(\".py\"):\n                import importlib.util\n                from importlib import machinery\n\n                spec = cast(\n                    machinery.ModuleSpec,\n                    importlib.util.spec_from_file_location(module, module),\n                )\n                module = importlib.util.module_from_spec(spec)\n                spec.loader = cast(InspectLoader, spec.loader)\n                spec.loader.exec_module(module)\n            else:\n                import importlib\n\n                module = importlib.import_module(module)\n        self._module: Optional[ModuleType] = module\n        self._prefix = prefix\n        self._strip_prefix = strip_prefix\n        self._separator = separator\n    except (FileNotFoundError, ModuleNotFoundError):\n        if not ignore_missing_paths:\n            raise\n        self._module = None\n\n    super().__init__(\n        {},\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n    self.reload()\n</code></pre>"},{"location":"reference/#config.PythonConfiguration.reload","title":"<code>reload()</code>","text":"<p>Reload the path.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the path.\"\"\"\n    if self._module is not None:\n        variables = [\n            x\n            for x in dir(self._module)\n            if not x.startswith(\"__\") and x.startswith(self._prefix)\n        ]\n        n = len(self._prefix) if self._strip_prefix else 0\n        result = {\n            k[n:].replace(self._separator, \".\").strip(\".\"): getattr(self._module, k)\n            for k in variables\n        }\n    else:\n        result = {}\n    super().__init__(\n        result,\n        lowercase_keys=self._lowercase,\n        interpolate=self._interpolate,\n        interpolate_type=self._interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.TOMLConfiguration","title":"<code>TOMLConfiguration</code>","text":"<p>               Bases: <code>FileConfiguration</code></p> <p>Configuration from a TOML input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class TOMLConfiguration(FileConfiguration):\n    \"\"\"Configuration from a TOML input.\"\"\"\n\n    def __init__(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n        *,\n        section_prefix: str = \"\",\n        strip_prefix: bool = True,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\"\"\"\n        if toml is None:  # pragma: no cover\n            raise ImportError(\n                \"Dependency &lt;toml&gt; is not found, but required by this class.\",\n            )\n\n        self._section_prefix = section_prefix\n        self._strip_prefix = strip_prefix\n        super().__init__(\n            data=data,\n            read_from_file=read_from_file,\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n            ignore_missing_paths=ignore_missing_paths,\n        )\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:\n        \"\"\"Reload the TOML data.\"\"\"\n        if read_from_file:\n            if isinstance(data, (str, Path)):\n                with open(data, \"rb\") as f:\n                    loaded = toml.load(f)\n            else:\n                loaded = toml.load(data)  # type: ignore [arg-type,unused-ignore]\n        else:\n            data = cast(str, data)\n            loaded = toml.loads(data)\n        loaded = cast(dict, loaded)\n\n        n = len(self._section_prefix) if self._section_prefix else 0\n        result = {\n            k[n:]: v\n            for k, v in self._flatten_dict(loaded).items()\n            if k.startswith(self._section_prefix)\n        }\n\n        self._config = result\n</code></pre>"},{"location":"reference/#config.TOMLConfiguration.__init__","title":"<code>__init__(data, read_from_file=False, *, section_prefix='', strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    section_prefix: str = \"\",\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\"\"\"\n    if toml is None:  # pragma: no cover\n        raise ImportError(\n            \"Dependency &lt;toml&gt; is not found, but required by this class.\",\n        )\n\n    self._section_prefix = section_prefix\n    self._strip_prefix = strip_prefix\n    super().__init__(\n        data=data,\n        read_from_file=read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.YAMLConfiguration","title":"<code>YAMLConfiguration</code>","text":"<p>               Bases: <code>FileConfiguration</code></p> <p>Configuration from a YAML input.</p> Source code in <code>src/config/__init__.py</code> <pre><code>class YAMLConfiguration(FileConfiguration):\n    \"\"\"Configuration from a YAML input.\"\"\"\n\n    def __init__(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n        *,\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n        ignore_missing_paths: bool = False,\n    ):\n        \"\"\"Class Constructor.\"\"\"\n        if yaml is None:  # pragma: no cover\n            raise ImportError(\n                \"Dependency &lt;yaml&gt; is not found, but required by this class.\",\n            )\n        super().__init__(\n            data=data,\n            read_from_file=read_from_file,\n            lowercase_keys=lowercase_keys,\n            interpolate=interpolate,\n            interpolate_type=interpolate_type,\n            ignore_missing_paths=ignore_missing_paths,\n        )\n\n    def _reload(\n        self,\n        data: Union[str, Path, TextIO],\n        read_from_file: bool = False,\n    ) -&gt; None:\n        \"\"\"Reload the YAML data.\"\"\"\n        if read_from_file and isinstance(data, (str, Path)):\n            with open(data, \"rt\") as f:\n                loaded = yaml.load(f, Loader=yaml.FullLoader)\n        else:\n            loaded = yaml.load(data, Loader=yaml.FullLoader)\n        if not isinstance(loaded, Mapping):\n            raise ValueError(\"Data should be a dictionary\")\n        self._config = self._flatten_dict(loaded)\n</code></pre>"},{"location":"reference/#config.YAMLConfiguration.__init__","title":"<code>__init__(data, read_from_file=False, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Class Constructor.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def __init__(\n    self,\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n):\n    \"\"\"Class Constructor.\"\"\"\n    if yaml is None:  # pragma: no cover\n        raise ImportError(\n            \"Dependency &lt;yaml&gt; is not found, but required by this class.\",\n        )\n    super().__init__(\n        data=data,\n        read_from_file=read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config","title":"<code>config(*configs, prefix='', strip_prefix=True, separator=None, remove_level=1, lowercase_keys=False, ignore_missing_paths=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Create a ConfigurationSet instance from an iterable of configs.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>Iterable</code> <p>iterable of configurations</p> <code>()</code> <code>prefix</code> <code>str</code> <p>prefix to filter environment variables with</p> <code>''</code> <code>strip_prefix</code> <code>bool</code> <p>whether to strip the prefix</p> <code>True</code> <code>remove_level</code> <code>int</code> <p>how many levels to remove from the resulting config</p> <code>1</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>whether to ignore failures from missing files/folders.</p> <code>False</code> <code>separator</code> <code>Optional[str]</code> <p>separator for Python modules and environment variables.</p> <code>None</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items</p> <code>False</code> <p>Note that the <code>separator</code> parameter  impacts Python modules and environment variables at the same time. To pass different separators to Python modules and environments, use the longer version <code>('python', 'path-to-module', prefix, separator)</code> and <code>('env', prefix, separator)</code> .</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config(\n    *configs: Iterable,\n    prefix: str = \"\",\n    strip_prefix: bool = True,\n    separator: Optional[str] = None,\n    remove_level: int = 1,\n    lowercase_keys: bool = False,\n    ignore_missing_paths: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n) -&gt; ConfigurationSet:\n    \"\"\"Create a [ConfigurationSet][config.configuration_set.ConfigurationSet] instance from an iterable of configs.\n\n    Params:\n       configs: iterable of configurations\n       prefix: prefix to filter environment variables with\n       strip_prefix: whether to strip the prefix\n       remove_level: how many levels to remove from the resulting config\n       lowercase_keys: whether to convert every key to lower case.\n       ignore_missing_paths: whether to ignore failures from missing files/folders.\n       separator: separator for Python modules and environment variables.\n       interpolate: whether to apply string interpolation when looking for items\n\n    Note that the `separator` parameter  impacts Python modules and\n    environment variables at the same time. To pass different separators to Python\n    modules and environments, use the longer version\n    ``('python', 'path-to-module', prefix, separator)``\n    and ``('env', prefix, separator)`` .\n    \"\"\"  # noqa: E501\n    instances = []\n    default_args: List[str] = [prefix]\n    if separator is not None:\n        default_args.append(separator)\n    default_kwargs: Dict[Any, Any] = {\n        \"lowercase_keys\": lowercase_keys,\n        # for Configuration Sets, interpolate parameters should be at the Set level\n        \"interpolate\": False,\n        \"interpolate_type\": InterpolateEnumType.STANDARD,\n    }\n\n    for config_ in configs:\n        if isinstance(config_, Mapping):\n            instances.append(config_from_dict(config_, **default_kwargs))\n            continue\n        elif isinstance(config_, Configuration):\n            instances.append(config_)\n            continue\n        elif isinstance(config_, str):\n            if config_.endswith(\".py\"):\n                config_ = (\"python\", config_, *default_args)\n            elif config_.endswith(\".json\"):\n                config_ = (\"json\", config_, True)\n            elif yaml and config_.endswith(\".yaml\"):\n                config_ = (\"yaml\", config_, True)\n            elif toml and config_.endswith(\".toml\"):\n                config_ = (\"toml\", config_, True)\n            elif config_.endswith(\".ini\"):\n                config_ = (\"ini\", config_, True)\n            elif config_.endswith(\".env\") or config_.startswith(\".env\"):\n                config_ = (\"dotenv\", config_, True, *default_args)\n            elif os.path.isdir(config_):\n                config_ = (\"path\", config_, remove_level)\n            elif config_ in (\"env\", \"environment\"):\n                config_ = (\"env\", *default_args)\n            elif all(s and s.isidentifier() for s in config_.split(\".\")):\n                config_ = (\"python\", config_, *default_args)\n            else:\n                raise ValueError(f'Cannot determine config type from \"{config_}\"')\n\n        if not isinstance(config_, (tuple, list)) or len(config_) == 0:\n            raise ValueError(\n                \"configuration parameters must be a list of dictionaries,\"\n                \" strings, or non-empty tuples/lists\",\n            )\n        type_ = config_[0]\n        if type_ == \"dict\":\n            instances.append(config_from_dict(*config_[1:], **default_kwargs))\n        elif type_ in (\"env\", \"environment\"):\n            params = list(config_[1:]) + default_args[(len(config_) - 1) :]\n            instances.append(\n                config_from_env(\n                    *params,\n                    **default_kwargs,\n                    strip_prefix=strip_prefix,\n                ),\n            )\n        elif type_ == \"python\":\n            if len(config_) &lt; 2:\n                raise ValueError(\"No path specified for python module\")\n            params = list(config_[1:]) + default_args[(len(config_) - 2) :]\n            instances.append(\n                config_from_python(\n                    *params,\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                    strip_prefix=strip_prefix,\n                ),\n            )\n        elif type_ == \"json\":\n            instances.append(\n                config_from_json(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                ),\n            )\n        elif yaml and type_ == \"yaml\":\n            instances.append(\n                config_from_yaml(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                ),\n            )\n        elif toml and type_ == \"toml\":\n            instances.append(\n                config_from_toml(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                    strip_prefix=strip_prefix,\n                ),\n            )\n        elif type_ == \"ini\":\n            instances.append(\n                config_from_ini(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                    strip_prefix=strip_prefix,\n                ),\n            )\n        elif type_ == \"dotenv\":\n            instances.append(\n                config_from_dotenv(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                    strip_prefix=strip_prefix,\n                ),\n            )\n        elif type_ == \"path\":\n            instances.append(\n                config_from_path(\n                    *config_[1:],\n                    **default_kwargs,\n                    ignore_missing_paths=ignore_missing_paths,\n                ),\n            )\n        else:\n            raise ValueError(f'Unknown configuration type \"{type_}\"')\n\n    return ConfigurationSet(\n        *instances,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_dict","title":"<code>config_from_dict(data, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Create a Configuration instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping</code> <p>dictionary with string keys.</p> required <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_dict(\n    data: Mapping,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from a dictionary.\n\n    Params:\n        data: dictionary with string keys.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return Configuration(\n        data,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_dotenv","title":"<code>config_from_dotenv(data, read_from_file=False, prefix='', separator='__', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Create a Configuration instance from a .env type file.</p> <p>Lines starting with a # are ignored and treated as comments.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Path, TextIO]</code> <p>path to a .env type file or contents.</p> required <code>read_from_file</code> <code>bool</code> <p>whether to read from a file path or to interpret. the <code>data</code> as the contents of the INI file.</p> <code>False</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>if true it will not throw on missing paths.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_dotenv(\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    prefix: str = \"\",\n    separator: str = \"__\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from a .env type file.\n\n    Lines starting with a # are ignored and treated as comments.\n\n    Params:\n        data: path to a .env type file or contents.\n        read_from_file: whether to read from a file path or to interpret.\n            the `data` as the contents of the INI file.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n        ignore_missing_paths: if true it will not throw on missing paths.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return DotEnvConfiguration(\n        data,\n        read_from_file,\n        prefix=prefix,\n        separator=separator,\n        strip_prefix=strip_prefix,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_env","title":"<code>config_from_env(prefix, separator='__', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Create a EnvConfiguration instance from environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix to filter environment variables with.</p> required <code>separator</code> <code>str</code> <p>separator to replace by dots.</p> <code>'__'</code> <code>strip_prefix</code> <code>bool</code> <p>whether to include the prefix</p> <code>True</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_env(\n    prefix: str,\n    separator: str = \"__\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n) -&gt; Configuration:\n    \"\"\"Create a [EnvConfiguration][config.EnvConfiguration] instance from environment variables.\n\n    Params:\n        prefix: prefix to filter environment variables with.\n        separator: separator to replace by dots.\n        strip_prefix: whether to include the prefix\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return EnvConfiguration(\n        prefix,\n        separator,\n        strip_prefix=strip_prefix,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_ini","title":"<code>config_from_ini(data, read_from_file=False, *, section_prefix='', strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Create a Configuration instance from an INI file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Path, TextIO]</code> <p>path to an INI file or contents.</p> required <code>read_from_file</code> <code>bool</code> <p>whether to read from a file path or to interpret. the <code>data</code> as the contents of the INI file.</p> <code>False</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>if true it will not throw on missing paths.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_ini(\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    section_prefix: str = \"\",\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from an INI file.\n\n    Params:\n        data: path to an INI file or contents.\n        read_from_file: whether to read from a file path or to interpret.\n            the `data` as the contents of the INI file.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n        ignore_missing_paths: if true it will not throw on missing paths.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return INIConfiguration(\n        data,\n        read_from_file,\n        section_prefix=section_prefix,\n        strip_prefix=strip_prefix,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_json","title":"<code>config_from_json(data, read_from_file=False, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Create a Configuration instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Path, TextIO]</code> <p>path to a JSON file or contents.</p> required <code>read_from_file</code> <code>bool</code> <p>whether to read from a file path or to interpret. the <code>data</code> as the contents of the JSON file.</p> <code>False</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>if true it will not throw on missing paths.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_json(\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from a JSON file.\n\n    Params:\n        data: path to a JSON file or contents.\n        read_from_file: whether to read from a file path or to interpret.\n            the `data` as the contents of the JSON file.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n        ignore_missing_paths: if true it will not throw on missing paths.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return JSONConfiguration(\n        data,\n        read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_path","title":"<code>config_from_path(path, remove_level=1, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Create a Configuration instance from filesystem path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to read from.</p> required <code>remove_level</code> <code>int</code> <p>how many levels to remove from the resulting config.</p> <code>1</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_path(\n    path: str,\n    remove_level: int = 1,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from filesystem path.\n\n    Params:\n        path: path to read from.\n        remove_level: how many levels to remove from the resulting config.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return PathConfiguration(\n        path,\n        remove_level,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_python","title":"<code>config_from_python(module, prefix='', separator='_', *, strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Create a Configuration instance from the objects in a Python module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Union[str, Path, ModuleType]</code> <p>a module or path string.</p> required <code>prefix</code> <code>str</code> <p>prefix to use to filter object names.</p> <code>''</code> <code>separator</code> <code>str</code> <p>separator to replace by dots.</p> <code>'_'</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_python(\n    module: Union[str, Path, ModuleType],\n    prefix: str = \"\",\n    separator: str = \"_\",\n    *,\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Create a [Configuration][config.configuration.Configuration] instance from the objects in a Python module.\n\n    Params:\n        module: a module or path string.\n        prefix: prefix to use to filter object names.\n        separator: separator to replace by dots.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n\n    Returns:\n        a [Configuration][config.configuration.Configuration] instance.\n    \"\"\"  # noqa: E501\n    return PythonConfiguration(\n        module,\n        prefix,\n        separator,\n        strip_prefix=strip_prefix,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_toml","title":"<code>config_from_toml(data, read_from_file=False, *, section_prefix='', strip_prefix=True, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Return a Configuration instance from TOML files.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Path, TextIO]</code> <p>string or file.</p> required <code>read_from_file</code> <code>bool</code> <p>whether <code>data</code> is a file or a TOML formatted string.</p> <code>False</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>if true it will not throw on missing paths.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_toml(\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    section_prefix: str = \"\",\n    strip_prefix: bool = True,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Return a Configuration instance from TOML files.\n\n    Params:\n        data: string or file.\n        read_from_file: whether `data` is a file or a TOML formatted string.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n        ignore_missing_paths: if true it will not throw on missing paths.\n\n    Returns:\n        a Configuration instance.\n    \"\"\"\n    return TOMLConfiguration(\n        data,\n        read_from_file,\n        section_prefix=section_prefix,\n        strip_prefix=strip_prefix,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.config_from_yaml","title":"<code>config_from_yaml(data, read_from_file=False, *, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD, ignore_missing_paths=False)</code>","text":"<p>Return a Configuration instance from YAML files.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Path, TextIO]</code> <p>string or file.</p> required <code>read_from_file</code> <code>bool</code> <p>whether <code>data</code> is a file or a YAML formatted string.</p> <code>False</code> <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> <code>interpolate</code> <code>InterpolateType</code> <p>whether to apply string interpolation when looking for items.</p> <code>False</code> <code>ignore_missing_paths</code> <code>bool</code> <p>if true it will not throw on missing paths.</p> <code>False</code> <p>Returns:</p> Type Description <code>Configuration</code> <p>a Configuration instance.</p> Source code in <code>src/config/__init__.py</code> <pre><code>def config_from_yaml(\n    data: Union[str, Path, TextIO],\n    read_from_file: bool = False,\n    *,\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ignore_missing_paths: bool = False,\n) -&gt; Configuration:\n    \"\"\"Return a Configuration instance from YAML files.\n\n    Params:\n        data: string or file.\n        read_from_file: whether `data` is a file or a YAML formatted string.\n        lowercase_keys: whether to convert every key to lower case.\n        interpolate: whether to apply string interpolation when looking for items.\n        ignore_missing_paths: if true it will not throw on missing paths.\n\n    Returns:\n        a Configuration instance.\n    \"\"\"\n    return YAMLConfiguration(\n        data,\n        read_from_file,\n        lowercase_keys=lowercase_keys,\n        interpolate=interpolate,\n        interpolate_type=interpolate_type,\n        ignore_missing_paths=ignore_missing_paths,\n    )\n</code></pre>"},{"location":"reference/#config.create_path_from_config","title":"<code>create_path_from_config(path, cfg, remove_level=1)</code>","text":"<p>Output a path configuration from a Configuration instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to create the config files in.</p> required <code>cfg</code> <code>Configuration</code> <p>Configuration instance.</p> required <code>remove_level</code> <code>int</code> <p>how many levels to remove.</p> <code>1</code> Source code in <code>src/config/__init__.py</code> <pre><code>def create_path_from_config(\n    path: str,\n    cfg: Configuration,\n    remove_level: int = 1,\n) -&gt; Configuration:\n    \"\"\"\n    Output a path configuration from a [Configuration][config.Configuration] instance.\n\n    Args:\n        path: path to create the config files in.\n        cfg: [Configuration][config.Configuration] instance.\n        remove_level: how many levels to remove.\n    \"\"\"\n    import os.path\n\n    assert os.path.isdir(path)\n\n    d = cfg.as_dict()\n    for k, v in d.items():\n        with open(os.path.join(path, k), \"wb\") as f:\n            f.write(str(v).encode())\n\n        cfg = config_from_path(path, remove_level=remove_level)\n    return cfg\n</code></pre>"},{"location":"reference/#config.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>Configuration class.</p> <p>The Configuration class takes a dictionary input with keys such as</p> <pre><code>- ``a1.b1.c1``\n- ``a1.b1.c2``\n- ``a1.b2.c1``\n- ``a1.b2.c2``\n- ``a2.b1.c1``\n- ``a2.b1.c2``\n- ``a2.b2.c1``\n- ``a2.b2.c2``\n</code></pre> Source code in <code>src/config/configuration.py</code> <pre><code>class Configuration:\n    \"\"\"Configuration class.\n\n    The Configuration class takes a dictionary input with keys such as\n\n        - ``a1.b1.c1``\n        - ``a1.b1.c2``\n        - ``a1.b2.c1``\n        - ``a1.b2.c2``\n        - ``a2.b1.c1``\n        - ``a2.b1.c2``\n        - ``a2.b2.c1``\n        - ``a2.b2.c2``\n    \"\"\"\n\n    def __init__(\n        self,\n        config_: Mapping[str, Any],\n        lowercase_keys: bool = False,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ):\n        \"\"\"Class Constructor.\n\n        Params:\n            config_: a mapping of configuration values. Keys need to be strings.\n            lowercase_keys: whether to convert every key to lower case.\n        \"\"\"\n        self._lowercase = lowercase_keys\n        self._interpolate = {} if interpolate is True else interpolate\n        self._interpolate_type = interpolate_type\n        self._config: Dict[str, Any] = self._flatten_dict(config_)\n        self._default_levels: Optional[int] = 1\n\n    def __eq__(self, other):  # type: ignore\n        \"\"\"Equality operator.\"\"\"\n        if not isinstance(other, (Configuration, Mapping)):\n            return False\n        return self.as_dict() == Configuration(other).as_dict()\n\n    def _filter_dict(self, d: Dict[str, Any], prefix: str) -&gt; Dict[str, Any]:\n        \"\"\"Filter a dictionary and return the items that are prefixed by `prefix`.\n\n        Params:\n            d: dictionary.\n            prefix: prefix to filter on.\n        \"\"\"\n        if self._lowercase:\n            return {\n                k[(len(prefix) + 1) :].lower(): v\n                for k, v in d.items()\n                for k, v in d.items()\n                if k.startswith(prefix + \".\")\n            }\n        else:\n            return {\n                k[(len(prefix) + 1) :]: v\n                for k, v in d.items()\n                if k.startswith(prefix + \".\")\n            }\n\n    def _flatten_dict(self, d: Mapping[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Flatten one level of a dictionary.\n\n        Params:\n            d: dict.\n\n        Returns:\n            a flattened dict.\n        \"\"\"\n        nested = {k for k, v in d.items() if isinstance(v, (Mapping, Configuration))}\n        if self._lowercase:\n            result = {\n                k.lower() + \".\" + ki: vi\n                for k in nested\n                for ki, vi in self._flatten_dict(d[k]).items()\n            }\n            result.update(\n                (k.lower(), v)\n                for k, v in d.items()\n                if not isinstance(v, (Mapping, Configuration))\n            )\n        else:\n            result = {\n                k + \".\" + ki: vi\n                for k in nested\n                for ki, vi in self._flatten_dict(d[k]).items()\n            }\n            result.update(\n                (k, v)\n                for k, v in d.items()\n                if not isinstance(v, (Mapping, Configuration))\n            )\n        return result\n\n    def _get_subset(self, prefix: str) -&gt; Union[Dict[str, Any], Any]:\n        \"\"\"Return the subset of the config dictionary whose keys start with `prefix`.\n\n        Params:\n            prefix: string.\n\n        Returns:\n            dict.\n        \"\"\"  # noqa: E501\n        d = {\n            k[(len(prefix) + 1) :]: v\n            for k, v in self._config.items()\n            if k.startswith(prefix + \".\")\n        }\n        if not d:\n            prefixes = prefix.split(\".\")\n            if len(prefixes) == 1:\n                return deepcopy(self._config.get(prefix, {}))\n            d = self._config\n            while prefixes:  # pragma: no branches\n                p = prefixes[0]\n                new_d = self._filter_dict(d, p)\n                if new_d == {}:\n                    return deepcopy(d.get(p, {}) if len(prefixes) == 1 else {})\n                d = new_d\n                prefixes = prefixes[1:]\n        return deepcopy(d)\n\n    def __getitem__(self, item: str) -&gt; Union[\"Configuration\", Any]:  # noqa: D105\n        v = self._get_subset(item)\n\n        if v == {}:\n            raise KeyError(item)\n        if isinstance(v, Mapping):\n            return Configuration(v)\n        elif self._interpolate is not False:\n            d = self.as_dict()\n            d.update(self._interpolate)\n            return interpolate_object(item, v, [d], self._interpolate_type)\n        else:\n            return v\n\n    def __getattr__(self, item: str) -&gt; Any:  # noqa: D105\n        try:\n            return self[item]\n        except KeyError:\n            raise AttributeError(item) from None\n\n    def get(self, key: str, default: Any = None) -&gt; Union[dict, Any]:\n        \"\"\"Get the configuration values corresponding to `key`.\n\n        Params:\n            key: key to retrieve.\n            default: default value in case the key is missing.\n\n        Returns:\n            the value found or a default.\n        \"\"\"\n        return self.as_dict().get(key, default)\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"Return the representation as a dictionary.\"\"\"\n        return self._config\n\n    def as_attrdict(self) -&gt; AttributeDict:\n        \"\"\"Return the representation as an attribute dictionary.\"\"\"\n        return AttributeDict(\n            {\n                x: Configuration(v).as_attrdict() if isinstance(v, Mapping) else v\n                for x, v in self.items(levels=1)\n            },\n        )\n\n    def get_bool(self, item: str) -&gt; bool:\n        \"\"\"Get the item value as a bool.\n\n        Params:\n            item: key\n        \"\"\"\n        return as_bool(self[item])\n\n    def get_str(self, item: str, fmt: str = \"{}\") -&gt; str:\n        \"\"\"Get the item value as an int.\n\n        Params:\n            item: key\n            fmt: format to use\n        \"\"\"\n        return fmt.format(self[item])\n\n    def get_int(self, item: str) -&gt; int:\n        \"\"\"Get the item value as an int.\n\n        Params:\n            item: key\n        \"\"\"\n        return int(self[item])\n\n    def get_float(self, item: str) -&gt; float:\n        \"\"\"Get the item value as a float.\n\n        Params:\n            item: key\n        \"\"\"\n        return float(self[item])\n\n    def get_list(self, item: str) -&gt; List[Any]:\n        \"\"\"Get the item value as a list.\n\n        Params:\n            item: key\n        \"\"\"\n        return list(self[item])\n\n    def get_dict(self, item: str) -&gt; dict:\n        \"\"\"Get the item values as a dictionary.\n\n        Params:\n            item: key\n        \"\"\"\n        return dict(self._get_subset(item))\n\n    def base64encode(self, item: str) -&gt; bytes:\n        \"\"\"Get the item value as a Base64 encoded bytes instance.\n\n        Params:\n            item: key\n        \"\"\"\n        b = self[item]\n        b = b if isinstance(b, bytes) else b.encode()\n        return base64.b64encode(b)\n\n    def base64decode(self, item: str) -&gt; bytes:\n        \"\"\"Get the item value as a Base64 decoded bytes instance.\n\n        Params:\n            item: key\n        \"\"\"\n        b = self[item]\n        b = b if isinstance(b, bytes) else b.encode()\n        return base64.b64decode(b, validate=True)\n\n    def keys(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, KeysView[str]]:\n        \"\"\"Return a set-like object providing a view on the configuration keys.\"\"\"\n        assert levels is None or levels &gt; 0\n        levels = self._default_levels if levels is None else levels\n        try:\n            return self[\"keys\"]  # don't filter levels, existing attribute\n        except KeyError:\n            return cast(\n                KeysView[str],\n                list(\n                    {\n                        \".\".join(x.split(\".\")[:levels])\n                        for x in set(self.as_dict().keys())\n                    },\n                ),\n            )\n\n    def values(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, ValuesView[Any]]:\n        \"\"\"Return a set-like object providing a view on the configuration values.\"\"\"\n        assert levels is None or levels &gt; 0\n        levels = self._default_levels if levels is None else levels\n        try:\n            return self[\"values\"]\n        except KeyError:\n            return dict(self.items(levels=levels)).values()\n\n    def items(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, ItemsView[str, Any]]:\n        \"\"\"Return a set-like object providing a view on the configuration items.\"\"\"\n        assert levels is None or levels &gt; 0\n        levels = self._default_levels if levels is None else levels\n        try:\n            return self[\"items\"]\n        except KeyError:\n            keys = cast(KeysView[str], self.keys(levels=levels))\n            return {k: self._get_subset(k) for k in keys}.items()\n\n    def __iter__(self) -&gt; Iterator[Tuple[str, Any]]:  # noqa: D105\n        return iter(dict(self.items()))  # type: ignore\n\n    def __reversed__(self) -&gt; Iterator[Tuple[str, Any]]:  # noqa: D105\n        if version_info &lt; (3, 8):\n            return OrderedDict(\n                reversed(list(self.items())),\n            )  # type: ignore  # pragma: no cover\n        else:\n            return reversed(dict(self.items()))  # type: ignore\n\n    def __len__(self) -&gt; int:  # noqa: D105\n        return len(self.keys())\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:  # noqa: D105\n        self.update({key: value})\n\n    def __delitem__(self, prefix: str) -&gt; None:  # noqa: D105\n        \"\"\"Filter a dictionary and delete the items that are prefixed by `prefix`.\n\n        Params:\n            prefix: prefix to filter on to delete keys\n        \"\"\"\n        remove = []\n        for k in self._config:\n            kl = k.lower() if self._lowercase else k\n            if kl == prefix or kl.startswith(prefix + \".\"):\n                remove.append(k)\n        if not remove:\n            raise KeyError(\"No key with prefix '%s' found.\" % prefix)\n        for k in remove:\n            del self._config[k]\n\n    def __contains__(self, prefix: str) -&gt; bool:  # noqa: D105\n        try:\n            self[prefix]\n            return True\n        except KeyError:\n            return False\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items.\"\"\"\n        self._config.clear()\n\n    def copy(self) -&gt; \"Configuration\":\n        \"\"\"Return shallow copy.\"\"\"\n        return Configuration(self._config)\n\n    def pop(self, prefix: str, value: Any = None) -&gt; Any:\n        \"\"\"Remove keys with the specified prefix and return the corresponding value.\n\n        If the prefix is not found a KeyError is raised.\n        \"\"\"\n        try:\n            value = self[prefix]\n            del self[prefix]\n        except KeyError:\n            if value is None:\n                raise\n        return value\n\n    def setdefault(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Insert key with a value of default if key is not in the Configuration.\n\n        Return the value for key if key is in the Configuration, else default.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            self[key] = default\n        return self[key]\n\n    def update(self, other: Mapping[str, Any]) -&gt; None:\n        \"\"\"Update the Configuration with another Configuration object or Mapping.\"\"\"\n        self._config.update(self._flatten_dict(other))\n\n    def reload(self) -&gt; None:  # pragma: no cover\n        \"\"\"Reload the configuration.\n\n        This method is not implemented for simple Configuration objects and is\n        intended only to be used in subclasses.\n        \"\"\"\n        raise NotImplementedError()\n\n    def validate(\n        self,\n        schema: Any,\n        raise_on_error: bool = False,\n        nested: bool = False,\n        **kwargs: Mapping[str, Any],\n    ) -&gt; bool:\n        \"\"\"Validate the current config using JSONSchema.\"\"\"\n        try:\n            from jsonschema import ValidationError, validate\n        except ImportError:  # pragma: no cover\n            raise RuntimeError(\n                \"Validation requires the `jsonschema` library.\",\n            ) from None\n        try:\n            validate(self.as_attrdict() if nested else self.as_dict(), schema, **kwargs)\n        except ValidationError as err:\n            if raise_on_error:\n                raise err\n            return False\n        return True\n\n    @contextmanager\n    def dotted_iter(self) -&gt; Iterator[\"Configuration\"]:\n        \"\"\"\n        Context manager for dotted iteration.\n\n        This context manager changes all the iterator-related functions\n        to include every nested (dotted) key instead of just the top level.\n        \"\"\"\n        self._default_levels = None\n        try:\n            yield self\n        finally:\n            self._default_levels = 1\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return \"&lt;%s: %s&gt;\" % (type(self).__name__, hex(id(self)))\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return str({k: clean(k, v) for k, v in sorted(self.as_dict().items())})\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.__delitem__","title":"<code>__delitem__(prefix)</code>","text":"<p>Filter a dictionary and delete the items that are prefixed by <code>prefix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix to filter on to delete keys</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def __delitem__(self, prefix: str) -&gt; None:  # noqa: D105\n    \"\"\"Filter a dictionary and delete the items that are prefixed by `prefix`.\n\n    Params:\n        prefix: prefix to filter on to delete keys\n    \"\"\"\n    remove = []\n    for k in self._config:\n        kl = k.lower() if self._lowercase else k\n        if kl == prefix or kl.startswith(prefix + \".\"):\n            remove.append(k)\n    if not remove:\n        raise KeyError(\"No key with prefix '%s' found.\" % prefix)\n    for k in remove:\n        del self._config[k]\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality operator.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def __eq__(self, other):  # type: ignore\n    \"\"\"Equality operator.\"\"\"\n    if not isinstance(other, (Configuration, Mapping)):\n        return False\n    return self.as_dict() == Configuration(other).as_dict()\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.__init__","title":"<code>__init__(config_, lowercase_keys=False, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Class Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config_</code> <code>Mapping[str, Any]</code> <p>a mapping of configuration values. Keys need to be strings.</p> required <code>lowercase_keys</code> <code>bool</code> <p>whether to convert every key to lower case.</p> <code>False</code> Source code in <code>src/config/configuration.py</code> <pre><code>def __init__(\n    self,\n    config_: Mapping[str, Any],\n    lowercase_keys: bool = False,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n):\n    \"\"\"Class Constructor.\n\n    Params:\n        config_: a mapping of configuration values. Keys need to be strings.\n        lowercase_keys: whether to convert every key to lower case.\n    \"\"\"\n    self._lowercase = lowercase_keys\n    self._interpolate = {} if interpolate is True else interpolate\n    self._interpolate_type = interpolate_type\n    self._config: Dict[str, Any] = self._flatten_dict(config_)\n    self._default_levels: Optional[int] = 1\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.as_attrdict","title":"<code>as_attrdict()</code>","text":"<p>Return the representation as an attribute dictionary.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def as_attrdict(self) -&gt; AttributeDict:\n    \"\"\"Return the representation as an attribute dictionary.\"\"\"\n    return AttributeDict(\n        {\n            x: Configuration(v).as_attrdict() if isinstance(v, Mapping) else v\n            for x, v in self.items(levels=1)\n        },\n    )\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the representation as a dictionary.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return the representation as a dictionary.\"\"\"\n    return self._config\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.base64decode","title":"<code>base64decode(item)</code>","text":"<p>Get the item value as a Base64 decoded bytes instance.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def base64decode(self, item: str) -&gt; bytes:\n    \"\"\"Get the item value as a Base64 decoded bytes instance.\n\n    Params:\n        item: key\n    \"\"\"\n    b = self[item]\n    b = b if isinstance(b, bytes) else b.encode()\n    return base64.b64decode(b, validate=True)\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.base64encode","title":"<code>base64encode(item)</code>","text":"<p>Get the item value as a Base64 encoded bytes instance.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def base64encode(self, item: str) -&gt; bytes:\n    \"\"\"Get the item value as a Base64 encoded bytes instance.\n\n    Params:\n        item: key\n    \"\"\"\n    b = self[item]\n    b = b if isinstance(b, bytes) else b.encode()\n    return base64.b64encode(b)\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.clear","title":"<code>clear()</code>","text":"<p>Remove all items.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items.\"\"\"\n    self._config.clear()\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.copy","title":"<code>copy()</code>","text":"<p>Return shallow copy.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def copy(self) -&gt; \"Configuration\":\n    \"\"\"Return shallow copy.\"\"\"\n    return Configuration(self._config)\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.dotted_iter","title":"<code>dotted_iter()</code>","text":"<p>Context manager for dotted iteration.</p> <p>This context manager changes all the iterator-related functions to include every nested (dotted) key instead of just the top level.</p> Source code in <code>src/config/configuration.py</code> <pre><code>@contextmanager\ndef dotted_iter(self) -&gt; Iterator[\"Configuration\"]:\n    \"\"\"\n    Context manager for dotted iteration.\n\n    This context manager changes all the iterator-related functions\n    to include every nested (dotted) key instead of just the top level.\n    \"\"\"\n    self._default_levels = None\n    try:\n        yield self\n    finally:\n        self._default_levels = 1\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get","title":"<code>get(key, default=None)</code>","text":"<p>Get the configuration values corresponding to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to retrieve.</p> required <code>default</code> <code>Any</code> <p>default value in case the key is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, Any]</code> <p>the value found or a default.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Union[dict, Any]:\n    \"\"\"Get the configuration values corresponding to `key`.\n\n    Params:\n        key: key to retrieve.\n        default: default value in case the key is missing.\n\n    Returns:\n        the value found or a default.\n    \"\"\"\n    return self.as_dict().get(key, default)\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_bool","title":"<code>get_bool(item)</code>","text":"<p>Get the item value as a bool.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def get_bool(self, item: str) -&gt; bool:\n    \"\"\"Get the item value as a bool.\n\n    Params:\n        item: key\n    \"\"\"\n    return as_bool(self[item])\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_dict","title":"<code>get_dict(item)</code>","text":"<p>Get the item values as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def get_dict(self, item: str) -&gt; dict:\n    \"\"\"Get the item values as a dictionary.\n\n    Params:\n        item: key\n    \"\"\"\n    return dict(self._get_subset(item))\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_float","title":"<code>get_float(item)</code>","text":"<p>Get the item value as a float.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def get_float(self, item: str) -&gt; float:\n    \"\"\"Get the item value as a float.\n\n    Params:\n        item: key\n    \"\"\"\n    return float(self[item])\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_int","title":"<code>get_int(item)</code>","text":"<p>Get the item value as an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def get_int(self, item: str) -&gt; int:\n    \"\"\"Get the item value as an int.\n\n    Params:\n        item: key\n    \"\"\"\n    return int(self[item])\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_list","title":"<code>get_list(item)</code>","text":"<p>Get the item value as a list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required Source code in <code>src/config/configuration.py</code> <pre><code>def get_list(self, item: str) -&gt; List[Any]:\n    \"\"\"Get the item value as a list.\n\n    Params:\n        item: key\n    \"\"\"\n    return list(self[item])\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.get_str","title":"<code>get_str(item, fmt='{}')</code>","text":"<p>Get the item value as an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key</p> required <code>fmt</code> <code>str</code> <p>format to use</p> <code>'{}'</code> Source code in <code>src/config/configuration.py</code> <pre><code>def get_str(self, item: str, fmt: str = \"{}\") -&gt; str:\n    \"\"\"Get the item value as an int.\n\n    Params:\n        item: key\n        fmt: format to use\n    \"\"\"\n    return fmt.format(self[item])\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.items","title":"<code>items(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration items.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def items(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, ItemsView[str, Any]]:\n    \"\"\"Return a set-like object providing a view on the configuration items.\"\"\"\n    assert levels is None or levels &gt; 0\n    levels = self._default_levels if levels is None else levels\n    try:\n        return self[\"items\"]\n    except KeyError:\n        keys = cast(KeysView[str], self.keys(levels=levels))\n        return {k: self._get_subset(k) for k in keys}.items()\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.keys","title":"<code>keys(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration keys.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def keys(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, KeysView[str]]:\n    \"\"\"Return a set-like object providing a view on the configuration keys.\"\"\"\n    assert levels is None or levels &gt; 0\n    levels = self._default_levels if levels is None else levels\n    try:\n        return self[\"keys\"]  # don't filter levels, existing attribute\n    except KeyError:\n        return cast(\n            KeysView[str],\n            list(\n                {\n                    \".\".join(x.split(\".\")[:levels])\n                    for x in set(self.as_dict().keys())\n                },\n            ),\n        )\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.pop","title":"<code>pop(prefix, value=None)</code>","text":"<p>Remove keys with the specified prefix and return the corresponding value.</p> <p>If the prefix is not found a KeyError is raised.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def pop(self, prefix: str, value: Any = None) -&gt; Any:\n    \"\"\"Remove keys with the specified prefix and return the corresponding value.\n\n    If the prefix is not found a KeyError is raised.\n    \"\"\"\n    try:\n        value = self[prefix]\n        del self[prefix]\n    except KeyError:\n        if value is None:\n            raise\n    return value\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.reload","title":"<code>reload()</code>","text":"<p>Reload the configuration.</p> <p>This method is not implemented for simple Configuration objects and is intended only to be used in subclasses.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def reload(self) -&gt; None:  # pragma: no cover\n    \"\"\"Reload the configuration.\n\n    This method is not implemented for simple Configuration objects and is\n    intended only to be used in subclasses.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Insert key with a value of default if key is not in the Configuration.</p> <p>Return the value for key if key is in the Configuration, else default.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def setdefault(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Insert key with a value of default if key is not in the Configuration.\n\n    Return the value for key if key is in the Configuration, else default.\n    \"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        self[key] = default\n    return self[key]\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.update","title":"<code>update(other)</code>","text":"<p>Update the Configuration with another Configuration object or Mapping.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def update(self, other: Mapping[str, Any]) -&gt; None:\n    \"\"\"Update the Configuration with another Configuration object or Mapping.\"\"\"\n    self._config.update(self._flatten_dict(other))\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.validate","title":"<code>validate(schema, raise_on_error=False, nested=False, **kwargs)</code>","text":"<p>Validate the current config using JSONSchema.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def validate(\n    self,\n    schema: Any,\n    raise_on_error: bool = False,\n    nested: bool = False,\n    **kwargs: Mapping[str, Any],\n) -&gt; bool:\n    \"\"\"Validate the current config using JSONSchema.\"\"\"\n    try:\n        from jsonschema import ValidationError, validate\n    except ImportError:  # pragma: no cover\n        raise RuntimeError(\n            \"Validation requires the `jsonschema` library.\",\n        ) from None\n    try:\n        validate(self.as_attrdict() if nested else self.as_dict(), schema, **kwargs)\n    except ValidationError as err:\n        if raise_on_error:\n            raise err\n        return False\n    return True\n</code></pre>"},{"location":"reference/#config.configuration.Configuration.values","title":"<code>values(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration values.</p> Source code in <code>src/config/configuration.py</code> <pre><code>def values(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, ValuesView[Any]]:\n    \"\"\"Return a set-like object providing a view on the configuration values.\"\"\"\n    assert levels is None or levels &gt; 0\n    levels = self._default_levels if levels is None else levels\n    try:\n        return self[\"values\"]\n    except KeyError:\n        return dict(self.items(levels=levels)).values()\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet","title":"<code>ConfigurationSet</code>","text":"<p>               Bases: <code>Configuration</code></p> <p>Configuration Sets.</p> <p>A class that combines multiple Configuration instances in a hierarchical manner.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>class ConfigurationSet(Configuration):\n    \"\"\"Configuration Sets.\n\n    A class that combines multiple [Configuration][config.configuration.Configuration]\n    instances in a hierarchical manner.\n    \"\"\"\n\n    def __init__(\n        self,\n        *configs: Configuration,\n        interpolate: InterpolateType = False,\n        interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n    ):  # noqa: D107\n        \"\"\"Class Constructor.\"\"\"\n        self._interpolate = {} if interpolate is True else interpolate\n        self._interpolate_type = interpolate_type\n        try:\n            self._configs: List[Configuration] = list(configs)\n        except Exception:  # pragma: no cover\n            raise ValueError(\n                \"configs should be a non-empty iterable of Configuration objects\",\n            ) from None\n        if not self._configs:  # pragma: no cover\n            raise ValueError(\n                \"configs should be a non-empty iterable of Configuration objects\",\n            )\n        if not all(\n            isinstance(x, Configuration) for x in self._configs\n        ):  # pragma: no cover\n            raise ValueError(\n                \"configs should be a non-empty iterable of Configuration objects\",\n            )\n        self._writable = False\n        self._default_levels = 1\n\n    def _from_configs(self, attr: str, *args: Any, **kwargs: dict) -&gt; Any:\n        last_err = Exception()\n        values = []\n        for config_ in self._configs:\n            try:\n                values.append(getattr(config_, attr)(*args, **kwargs))\n            except Exception as err:\n                last_err = err\n                continue\n        if not values:\n            # raise the last error\n            raise last_err\n        if all(isinstance(v, Configuration) for v in values):\n            result: dict = {}\n            for v in values[::-1]:\n                result.update(v.as_dict())\n            return Configuration(result)\n        elif isinstance(values[0], Configuration):\n            result = {}\n            for v in values[::-1]:\n                if not isinstance(v, Configuration):\n                    continue\n                result.update(v)\n            return Configuration(result)\n        elif self._interpolate is not False:\n            d = [d.as_dict() for d in self._configs]\n            d[0].update(self._interpolate)\n            return interpolate_object(args[0], values[0], d, self._interpolate_type)\n        else:\n            return values[0]\n\n    def _writable_config(self) -&gt; Configuration:\n        if not self._writable:\n            lowercase = bool(self._configs and self._configs[0]._lowercase)\n            self._configs.insert(0, Configuration({}, lowercase_keys=lowercase))\n            self._writable = True\n        return self._configs[0]\n\n    @property\n    def configs(self) -&gt; List[Configuration]:\n        \"\"\"List of underlying configuration objects.\"\"\"\n        if self._writable:\n            return self._configs[1:]\n        else:\n            return list(self._configs)\n\n    @configs.setter\n    def configs(self, iterable: Iterable[Configuration]) -&gt; None:\n        if self._writable:\n            self._configs = [self._configs[0]] + list(iterable)\n        else:\n            self._configs = list(iterable)\n\n    def __getitem__(self, item: str) -&gt; Union[Configuration, Any]:  # noqa: D105\n        return self._from_configs(\"__getitem__\", item)\n\n    def __getattr__(self, item: str) -&gt; Union[Configuration, Any]:  # noqa: D105\n        return self._from_configs(\"__getattr__\", item)\n\n    def get(self, key: str, default: Any = None) -&gt; Union[dict, Any]:\n        \"\"\"Get the configuration values corresponding to `key`.\n\n        Params:\n            key: key to retrieve.\n            default: default value in case the key is missing.\n\n        Returns:\n            the value found or a default\n        \"\"\"\n        try:\n            return self[key]\n        except Exception:\n            return default\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"Return the representation as a dictionary.\"\"\"\n        result = {}\n        for config_ in self._configs[::-1]:\n            result.update(config_.as_dict())\n        return result\n\n    def get_dict(self, item: str) -&gt; dict:\n        \"\"\"Get the item values as a dictionary.\n\n        item: key\n        \"\"\"\n        return Configuration(dict(dict(self[item]).items())).as_dict()\n\n    def keys(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, KeysView[str]]:\n        \"\"\"Return a set-like object providing a view on the configuration keys.\"\"\"\n        if self._default_levels:\n            return Configuration(self.as_dict()).keys(levels or self._default_levels)\n        with Configuration(self.as_dict()).dotted_iter() as cfg:\n            return cfg.keys(levels)\n\n    def values(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, ValuesView[Any]]:\n        \"\"\"Return a set-like object providing a view on the configuration values.\"\"\"\n        if self._default_levels:\n            return Configuration(self.as_dict()).values(levels or self._default_levels)\n        with Configuration(self.as_dict()).dotted_iter() as cfg:\n            return cfg.values(levels)\n\n    def items(\n        self,\n        levels: Optional[int] = None,\n    ) -&gt; Union[\"Configuration\", Any, ItemsView[str, Any]]:\n        \"\"\"Return a set-like object providing a view on the configuration items.\"\"\"\n        if self._default_levels:\n            return Configuration(self.as_dict()).items(levels or self._default_levels)\n        with Configuration(self.as_dict()).dotted_iter() as cfg:\n            return cfg.items(levels)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:  # noqa: D105\n        cfg = self._writable_config()\n        cfg[key] = value\n\n    def __delitem__(self, prefix: str) -&gt; None:  # noqa: D105\n        removed = False\n        for cfg in self._configs:\n            try:\n                del cfg[prefix]\n                removed = True\n            except KeyError:\n                continue\n        if not removed:\n            raise KeyError()\n\n    def __contains__(self, prefix: str) -&gt; bool:  # noqa: D105\n        return any(prefix in cfg for cfg in self._configs)\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items.\"\"\"\n        for cfg in self._configs:\n            cfg.clear()\n\n    def copy(self) -&gt; \"Configuration\":\n        \"\"\"Return shallow copy.\"\"\"\n        return ConfigurationSet(*self._configs)\n\n    def update(self, other: Mapping[str, Any]) -&gt; None:\n        \"\"\"Update the ConfigurationSet with another Configuration object or Mapping.\"\"\"\n        cfg = self._writable_config()\n        cfg.update(other)\n\n    def reload(self) -&gt; None:\n        \"\"\"Reload the underlying configuration instances.\"\"\"\n        for cfg in self._configs:\n            with contextlib.suppress(NotImplementedError):\n                cfg.reload()\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return \"&lt;ConfigurationSet: %s&gt;\" % hex(id(self))\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return str({k: clean(k, v) for k, v in sorted(self.as_dict().items())})\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.configs","title":"<code>configs: List[Configuration]</code>  <code>property</code> <code>writable</code>","text":"<p>List of underlying configuration objects.</p>"},{"location":"reference/#config.configuration_set.ConfigurationSet.__init__","title":"<code>__init__(*configs, interpolate=False, interpolate_type=InterpolateEnumType.STANDARD)</code>","text":"<p>Class Constructor.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def __init__(\n    self,\n    *configs: Configuration,\n    interpolate: InterpolateType = False,\n    interpolate_type: InterpolateEnumType = InterpolateEnumType.STANDARD,\n):  # noqa: D107\n    \"\"\"Class Constructor.\"\"\"\n    self._interpolate = {} if interpolate is True else interpolate\n    self._interpolate_type = interpolate_type\n    try:\n        self._configs: List[Configuration] = list(configs)\n    except Exception:  # pragma: no cover\n        raise ValueError(\n            \"configs should be a non-empty iterable of Configuration objects\",\n        ) from None\n    if not self._configs:  # pragma: no cover\n        raise ValueError(\n            \"configs should be a non-empty iterable of Configuration objects\",\n        )\n    if not all(\n        isinstance(x, Configuration) for x in self._configs\n    ):  # pragma: no cover\n        raise ValueError(\n            \"configs should be a non-empty iterable of Configuration objects\",\n        )\n    self._writable = False\n    self._default_levels = 1\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the representation as a dictionary.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return the representation as a dictionary.\"\"\"\n    result = {}\n    for config_ in self._configs[::-1]:\n        result.update(config_.as_dict())\n    return result\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.clear","title":"<code>clear()</code>","text":"<p>Remove all items.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items.\"\"\"\n    for cfg in self._configs:\n        cfg.clear()\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.copy","title":"<code>copy()</code>","text":"<p>Return shallow copy.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def copy(self) -&gt; \"Configuration\":\n    \"\"\"Return shallow copy.\"\"\"\n    return ConfigurationSet(*self._configs)\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.get","title":"<code>get(key, default=None)</code>","text":"<p>Get the configuration values corresponding to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to retrieve.</p> required <code>default</code> <code>Any</code> <p>default value in case the key is missing.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, Any]</code> <p>the value found or a default</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Union[dict, Any]:\n    \"\"\"Get the configuration values corresponding to `key`.\n\n    Params:\n        key: key to retrieve.\n        default: default value in case the key is missing.\n\n    Returns:\n        the value found or a default\n    \"\"\"\n    try:\n        return self[key]\n    except Exception:\n        return default\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.get_dict","title":"<code>get_dict(item)</code>","text":"<p>Get the item values as a dictionary.</p> <p>item: key</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def get_dict(self, item: str) -&gt; dict:\n    \"\"\"Get the item values as a dictionary.\n\n    item: key\n    \"\"\"\n    return Configuration(dict(dict(self[item]).items())).as_dict()\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.items","title":"<code>items(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration items.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def items(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, ItemsView[str, Any]]:\n    \"\"\"Return a set-like object providing a view on the configuration items.\"\"\"\n    if self._default_levels:\n        return Configuration(self.as_dict()).items(levels or self._default_levels)\n    with Configuration(self.as_dict()).dotted_iter() as cfg:\n        return cfg.items(levels)\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.keys","title":"<code>keys(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration keys.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def keys(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, KeysView[str]]:\n    \"\"\"Return a set-like object providing a view on the configuration keys.\"\"\"\n    if self._default_levels:\n        return Configuration(self.as_dict()).keys(levels or self._default_levels)\n    with Configuration(self.as_dict()).dotted_iter() as cfg:\n        return cfg.keys(levels)\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.reload","title":"<code>reload()</code>","text":"<p>Reload the underlying configuration instances.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the underlying configuration instances.\"\"\"\n    for cfg in self._configs:\n        with contextlib.suppress(NotImplementedError):\n            cfg.reload()\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.update","title":"<code>update(other)</code>","text":"<p>Update the ConfigurationSet with another Configuration object or Mapping.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def update(self, other: Mapping[str, Any]) -&gt; None:\n    \"\"\"Update the ConfigurationSet with another Configuration object or Mapping.\"\"\"\n    cfg = self._writable_config()\n    cfg.update(other)\n</code></pre>"},{"location":"reference/#config.configuration_set.ConfigurationSet.values","title":"<code>values(levels=None)</code>","text":"<p>Return a set-like object providing a view on the configuration values.</p> Source code in <code>src/config/configuration_set.py</code> <pre><code>def values(\n    self,\n    levels: Optional[int] = None,\n) -&gt; Union[\"Configuration\", Any, ValuesView[Any]]:\n    \"\"\"Return a set-like object providing a view on the configuration values.\"\"\"\n    if self._default_levels:\n        return Configuration(self.as_dict()).values(levels or self._default_levels)\n    with Configuration(self.as_dict()).dotted_iter() as cfg:\n        return cfg.values(levels)\n</code></pre>"}]}